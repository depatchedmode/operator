{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"gradient","speed":0.5,"trackMouse":0,"mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos; vec3 getColor(int index) { switch(index) { case 0: return vec3(1, 1, 1); case 1: return vec3(0, 0, 0); case 2: return vec3(0, 0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(1, 1, 1); }void main() { vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); uv -= pos; uv /= (0.50*2.); uv = rotate(uv, (0.00 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1); fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false,"uniforms":{}}},{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"noise","speed":0.5,"trackMouse":0,"mouseMomentum":0,"parentLayer":"8b9108f6-6a40-4070-a95e-c70c98eb7b19","animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }vec4 permute(vec4 t) { return t * (t * 34.0 + 133.0); }vec3 grad(float hash) { vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0; vec3 cuboct = cube;float index0 = step(0.0, 1.0 - floor(hash / 16.0)); float index1 = step(0.0, floor(hash / 16.0) - 1.0);cuboct.x *= 1.0 - index0; cuboct.y *= 1.0 - index1; cuboct.z *= 1.0 - (1.0 - index0 - index1);float type = mod(floor(hash / 8.0), 2.0); vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));vec3 grad = cuboct * 1.22474487139 + rhomb;grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;return grad; } vec4 bccNoiseDerivativesPart(vec3 X) { vec3 b = floor(X); vec4 i4 = vec4(X - b, 2.5); vec3 v1 = b + floor(dot(i4, vec4(.25))); vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35))); vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35))); vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35))); vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0)); hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0)); hashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0); vec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4; vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0); vec4 aa = a * a; vec4 aaaa = aa * aa; vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y); vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w); vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4)); vec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations) + mat4x3(g1, g2, g3, g4) * aaaa; return vec4(derivative, dot(aaaa, extrapolations)); } vec4 bccNoiseDerivatives_XYBeforeZ(vec3 X) { mat3 orthonormalMap = mat3( 0.788675134594813, -0.211324865405187, -0.577350269189626, -0.211324865405187, 0.788675134594813, -0.577350269189626, 0.577350269189626, 0.577350269189626, 0.577350269189626); X = orthonormalMap * X; vec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5); return vec4(result.xyz * orthonormalMap, result.w); }out vec4 fragColor;const float PI = 3.14159265359;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec2 get2sNoise(vec2 uv, vec2 textureCoord) { vec4 noise = bccNoiseDerivatives_XYBeforeZ(vec3(uv * vec2(0.50, 1. - 0.50) * 0.7, 0.00 + uTime*0.02)); vec2 offset = noise.xy/7. + 0.5; return mix(textureCoord, offset, 0.50); }vec2 getNoiseOffset(vec2 uv, vec2 textureCoord) { return get2sNoise(uv, textureCoord); }void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y;vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); vec2 pos = mPos; vec2 st = (uv - pos) * vec2(aspectRatio, 1); st *= 12. * 1.00; st = rot(0.00 * -1. * 2.0 * PI) * st;vec2 noise = getNoiseOffset(st, uv); float dist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.00)));if (0 == 1) { dist = max(0., (0.5 - dist)); }uv = mix(uv, noise, dist); vec4 color = texture(uTexture, uv); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{}}},{"breakpoints":[],"visible":true,"locked":false,"aspectRatio":1.7777777777777777,"layerName":"","isElement":true,"opacity":1,"effects":[],"displace":0,"trackMouse":0,"anchorPoint":"topLeft","mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"shape","width":785,"widthMode":"fixed","height":378,"heightMode":"fixed","left":0.19333333333333333,"leftMode":"relative","top":0.22962962962962963,"topMode":"relative","rotation":0,"trackMouseMove":0,"pos":{"type":"Vec2","_x":0.5,"_y":0.5},"borderRadius":0,"gradientAngle":0,"strokeWidth":0,"coords":[[0,0],[785,0],[785,378],[0,378]],"fill":["#B7B7B7"],"fitToCanvas":false,"gradientType":"linear","type":"rectangle","stroke":["#000000"],"numSides":3,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * 1.00);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"uniforms":{}}},{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"noise","speed":0.51,"trackMouse":0,"mouseMomentum":0,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;const float PI = 3.14159265359;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 hash3(vec2 p) { vec3 q = vec3(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)), dot(p,vec2(419.2,371.9))); return fract(sin(q)*43758.5453); }float voronoise(vec2 uv, vec2 textureCoord) { float u = 1.; float v = 1.; uv *= vec2(0.50, 1.0 - 0.50); uv *= 2.91;vec2 x = uv; vec2 p = floor(x); vec2 f = fract(x); float k = 1.0 + 63.0 * pow(1.0-v,4.0); float va = 0.0; float wt = 0.0; for( int j=-2; j<=2; j++ ) for( int i=-2; i<=2; i++ ) { vec2 g = vec2( float(i),float(j) ); vec3 o = hash3( p + g ) * vec3(u,u,1.0); o.xy += 0.5 * vec2( sin(uTime * 0.1 + 0.29 + o.x * 6.28), cos(uTime * 0.1 + 0.29 + o.y * 6.28) ); vec2 r = g - f + o.xy; float d = dot(r,r); float ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k ); va += o.z*ww; wt += ww; } return va/wt; } vec2 getVoronoiNoise(vec2 uv, vec2 textureCoord) { vec2 offset = vec2(voronoise(uv, textureCoord), voronoise(uv + vec2(9.2, 1.2), textureCoord));return mix(textureCoord, offset, 0.62); }vec2 getNoiseOffset(vec2 uv, vec2 textureCoord) { return getVoronoiNoise(uv, textureCoord); }void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y;vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); vec2 pos = mPos; vec2 st = (uv - pos) * vec2(aspectRatio, 1); st *= 12. * 0.62; st = rot(0.07 * -1. * 2.0 * PI) * st;vec2 noise = getNoiseOffset(st, uv); float dist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.00)));if (0 == 1) { dist = max(0., (0.5 - dist)); }uv = mix(uv, noise, dist); vec4 color = texture(uTexture, uv); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{}}},{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"blur","trackMouse":0,"mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;const int kernelSize = 36;vec4 BoxBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0);vec2 pos = vec2(0.4753218884120171, 0.505722460658083) + mix(vec2(0), (uMousePos-0.5), 0.00); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos)); float amount = 2.00 * ease(0, mix(inner, outer, 0.42)); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount/144.; color += texture(tex, uv + vec2(x) * direction * vec2(0.44, 1. - 0.44)); } return color/float(kernelSize); }vec4 blur(vec2 uv, vec2 direction) { return BoxBlur(uTexture, uv, direction); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 0 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction); fragColor = color;}","#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;const int kernelSize = 36;vec4 BoxBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0);vec2 pos = vec2(0.4753218884120171, 0.505722460658083) + mix(vec2(0), (uMousePos-0.5), 0.00); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos)); float amount = 2.00 * ease(0, mix(inner, outer, 0.42)); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount/144.; color += texture(tex, uv + vec2(x) * direction * vec2(0.44, 1. - 0.44)); } return color/float(kernelSize); }vec4 blur(vec2 uv, vec2 direction) { return BoxBlur(uTexture, uv, direction); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 1 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction); fragColor = color;}","#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;const int kernelSize = 36;vec4 BoxBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0);vec2 pos = vec2(0.4753218884120171, 0.505722460658083) + mix(vec2(0), (uMousePos-0.5), 0.00); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos)); float amount = 2.00 * ease(0, mix(inner, outer, 0.42)); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount/144.; color += texture(tex, uv + vec2(x) * direction * vec2(0.44, 1. - 0.44)); } return color/float(kernelSize); }vec4 blur(vec2 uv, vec2 direction) { return BoxBlur(uTexture, uv, direction); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 2 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction); fragColor = color;}","#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;const int kernelSize = 36;vec4 BoxBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0);vec2 pos = vec2(0.4753218884120171, 0.505722460658083) + mix(vec2(0), (uMousePos-0.5), 0.00); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos)); float amount = 2.00 * ease(0, mix(inner, outer, 0.42)); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount/144.; color += texture(tex, uv + vec2(x) * direction * vec2(0.44, 1. - 0.44)); } return color/float(kernelSize); }vec4 blur(vec2 uv, vec2 direction) { return BoxBlur(uTexture, uv, direction); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 3 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"downSample":true,"depth":false,"uniforms":{},"passes":[{"prop":"vertical","value":1,"downSample":true},{"prop":"vertical","value":2,"downSample":true},{"prop":"vertical","value":3,"downSample":true}]}},{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"mouse","animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform sampler2D uPingPongTexture; uniform vec2 uResolution;const float PI = 3.1415926; const float ITERATIONS = 24.0;out vec4 fragColor;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }vec3 chromatic_aberration(vec3 color, vec2 uv, vec2 offset) { vec4 left = texture(uTexture, uv - offset); vec4 right = texture(uTexture, uv + offset);color.r = left.r; color.b = right.b;return color; }vec2 angleToDir(float angle) { float rad = angle * 2.0 * PI; return vec2(cos(rad), sin(rad)); }vec4 revealTrail(vec2 uv, vec2 mouseDir, float strength) { vec4 color = vec4(0); float zMix = strength; vec2 distorted = mouseDir * 0.4 * 0.23; color = texture(uTexture, uv - distorted); color.rgb = chromatic_aberration(color.rgb, uv - distorted, distorted * 0.00 * 0.12); color = mix(vec4(vec3(1, 1, 1), 1.00), color, zMix); return color; }vec4 getTrailColor(vec2 uv, vec2 mouseDir, float strength) { vec4 color = vec4(0); float aspectRatio = uResolution.x / uResolution.y;return revealTrail(uv, mouseDir, strength); }void main() { vec2 uv = vTextureCoord; vec2 pingpongUv = uv;vec3 mouseRgb = texture(uPingPongTexture, pingpongUv).rgb; vec3 mouseTrail = rgb2hsv(mouseRgb);float angle = mouseTrail.x; float strength = mouseTrail.z * (0.60 * 2.0); vec2 direction = angleToDir(angle); vec2 mouseDir = direction * strength;vec4 color = getTrailColor(uv, mouseDir, strength);fragColor = color; }","#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uPingPongTexture; uniform vec2 uPreviousMousePos; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.1415926; const float TWOPI = 6.2831852;out vec4 fragColor;vec3 hsv2rgb(vec3 c) { vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 liquify(vec2 st, float angle) { float aspectRatio = uResolution.x / uResolution.y; st.x *= aspectRatio; st = st * rot(angle * TWOPI); float amplitude = 0.003; for (float i = 1.0; i <= 5.0; i++) { st = st * rot(i / 5.0 * PI * 2.0); st += vec2( amplitude * cos(i * 5.0 * st.y + uTime * 0.02), amplitude * sin(i * 5.0 * st.x + uTime * 0.02) ); } st = st * rot(-angle * TWOPI); st.x /= aspectRatio; return st; }void main() { float aspectRatio = uResolution.x / uResolution.y; vec2 uv = vTextureCoord; vec2 correctedUv = uv * vec2(aspectRatio, 1.0);vec2 dir = (uMousePos - uPreviousMousePos) * vec2(aspectRatio, 1.0); float dist = length(dir); dir = normalize(dir);float rad = 0.02 * 0.4 * mix(aspectRatio, 1.0, 0.5); float angle = atan(dir.y, dir.x); if (angle < 0.0) angle += TWOPI;uv = mix(uv, liquify(uv, smoothstep(0.0, 1.0, angle)), 0.45);float t = clamp(dot(correctedUv - uPreviousMousePos * vec2(aspectRatio, 1.0), dir) / dist, 0.0, 1.0); vec2 closestPoint = mix(uPreviousMousePos, uMousePos, t) * vec2(aspectRatio, 1.0); float distanceToLine = distance(correctedUv, closestPoint);float s = smoothstep(rad, rad * 0.80, distanceToLine);vec3 color = vec3(angle / TWOPI, 1.0, 1.0); vec3 mouseColor = hsv2rgb(color);vec3 lastFrameColor = texture(uPingPongTexture, mix(uv, uv / 1.03 + 0.015, 0.06)).rgb; vec3 draw = mix(lastFrameColor, mouseColor, min(1.0, dist * s));fragColor = vec4(draw * pow(0.25, 0.1), 1.0); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }","#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false,"uniforms":{}}},{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"blur","trackMouse":0,"mouseMomentum":0,"parentLayer":"ba1e30e2-2e95-4e42-89a8-3e0dd7fb83bd","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;const int kernelSize = 36;vec4 BoxBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0);vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos)); float amount = 0.19 * ease(0, mix(inner, outer, 0.50)); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount/144.; color += texture(tex, uv + vec2(x) * direction * vec2(0.50, 1. - 0.50)); } return color/float(kernelSize); }vec4 blur(vec2 uv, vec2 direction) { return BoxBlur(uTexture, uv, direction); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 0 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction); fragColor = color;}","#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;const int kernelSize = 36;vec4 BoxBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0);vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos)); float amount = 0.19 * ease(0, mix(inner, outer, 0.50)); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount/144.; color += texture(tex, uv + vec2(x) * direction * vec2(0.50, 1. - 0.50)); } return color/float(kernelSize); }vec4 blur(vec2 uv, vec2 direction) { return BoxBlur(uTexture, uv, direction); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 1 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction); fragColor = color;}","#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;const int kernelSize = 36;vec4 BoxBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0);vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos)); float amount = 0.19 * ease(0, mix(inner, outer, 0.50)); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount/144.; color += texture(tex, uv + vec2(x) * direction * vec2(0.50, 1. - 0.50)); } return color/float(kernelSize); }vec4 blur(vec2 uv, vec2 direction) { return BoxBlur(uTexture, uv, direction); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 2 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction); fragColor = color;}","#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;const int kernelSize = 36;vec4 BoxBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0);vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos)); float amount = 0.19 * ease(0, mix(inner, outer, 0.50)); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount/144.; color += texture(tex, uv + vec2(x) * direction * vec2(0.50, 1. - 0.50)); } return color/float(kernelSize); }vec4 blur(vec2 uv, vec2 direction) { return BoxBlur(uTexture, uv, direction); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 3 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"downSample":true,"depth":false,"uniforms":{},"passes":[{"prop":"vertical","value":1,"downSample":true},{"prop":"vertical","value":2,"downSample":true},{"prop":"vertical","value":3,"downSample":true}]}},{"breakpoints":[],"visible":true,"locked":false,"aspectRatio":1.7777777777777777,"layerName":"","isElement":true,"opacity":1,"effects":["d0b80a25-9ac7-4f19-9fe6-501cb5272704","3976bb19-0691-4bd7-9f8a-5d4f39c65994","ba1e30e2-2e95-4e42-89a8-3e0dd7fb83bd"],"displace":0,"trackMouse":1,"anchorPoint":"topLeft","mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"shape","width":10,"widthMode":"fixed","height":10,"heightMode":"fixed","left":0.5,"leftMode":"relative","top":0.5,"topMode":"relative","rotation":0,"trackMouseMove":1,"pos":{"type":"Vec2","_x":0.5,"_y":0.5},"borderRadius":0,"gradientAngle":0,"strokeWidth":0,"coords":[[0,0],[10,0],[10,10],[0,10]],"fill":["#646464"],"fitToCanvas":false,"gradientType":"linear","type":"circle","stroke":["#000000"],"numSides":3,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 1.00);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * 1.00);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"uniforms":{}}},{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"dither","speed":0.33,"animating":true,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uResolution;const int MAX_LEVEL = 4; const float PI2 = 6.28318530718;float getBayerFromCoordLevelScaled(vec2 pixelpos, float scale) { float finalBayer = 0.0; float finalDivisor = 0.0; float layerMult = 1.0;for(float bayerLevel = float(MAX_LEVEL); bayerLevel >= 1.0; bayerLevel--) { float bayerSize = exp2(bayerLevel) * 0.5 / scale; vec2 bayercoord = mod(floor(pixelpos.xy / bayerSize), 2.0); layerMult *= 4.0;float byxx2 = bayercoord.x * 2.0;finalBayer += mix(byxx2, 3.0 - byxx2, bayercoord.y) / 3.0 * layerMult; finalDivisor += layerMult; }return finalBayer / finalDivisor; }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }float getBayerNoise(vec2 st, float delta, float scale) { return getBayerFromCoordLevelScaled(st * uResolution + delta, scale); }vec3 dither(vec3 color, vec2 st) { float delta = floor(uTime); vec2 offset = vec2(random(vec2(123,16) + delta), random(vec2(56,96) + delta)); float noise = 0.0; noise = getBayerNoise(st, delta, 1.); float dither = max(0.0001, 0.98); color += (noise - 0.505) * dither; return round(color * (1.0 / dither)) * dither; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float delta = floor(uTime); vec4 color = texture(uTexture, uv);if(color.a == 0.) { fragColor = vec4(0); return; }color.rgb = mix(color.rgb, dither(color.rgb, uv), 1.00); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"texture":{"src":"https://assets.unicorn.studio/media/blue_noise_med.png","sampler":"uBlueNoise"}}},{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"liquify","speed":1,"trackMouse":1,"mouseMomentum":0.58,"parentLayer":"3976bb19-0691-4bd7-9f8a-5d4f39c65994","animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform float uTime; uniform sampler2D uTexture;uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.14159265;mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 liquify(vec2 st) { float aspectRatio = uResolution.x / uResolution.y; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos - 0.5), 1.00); st -= pos; st.x *= aspectRatio; st = st * rot(0.51 * 2. * PI);float amplitude = 0.01 * mix(0.2, 0.2/(0.10 + 0.05), 0.25); for (float i = 1.0; i <= 5.0; i++) { st = st * rot(i / 5. * PI * 2.); float cosFactor = cos(i * (5.0 * (0.10 + 0.1)) * st.y + uTime * 0.025); st.x += amplitude * cosFactor; float sinFactor = sin(i * (5.0 * (0.10 + 0.1)) * st.x + uTime * 0.025); st.y += amplitude * sinFactor; }st = st * rot(0.51 * -1. * 2. * PI); st.x /= aspectRatio; st += pos;return st; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 liquifiedUV = liquify(uv); vec2 normalizedUv = normalize(liquifiedUV - uv); float distanceUv = length(liquifiedUV - uv); float chromAbb = 0.01 * 0.5;vec2 offsetR = liquifiedUV + chromAbb * normalizedUv * distanceUv; vec2 offsetG = liquifiedUV; vec2 offsetB = liquifiedUV - chromAbb * normalizedUv * distanceUv;vec4 colorR = texture(uTexture, mix(uv, offsetR, 0.35)); vec4 colorG = texture(uTexture, mix(uv, offsetG, 0.35)); vec4 colorB = texture(uTexture, mix(uv, offsetB, 0.35));vec4 color = vec4(colorR.r, colorG.g, colorB.b, colorR.a * colorG.a * colorB.a); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{}}},{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"fbm","speed":0.68,"trackMouse":0.36,"mouseMomentum":0,"parentLayer":"d0b80a25-9ac7-4f19-9fe6-501cb5272704","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime;uniform sampler2D uMaskTexture; uniform vec2 uMousePos; uniform vec2 uResolution;float ease (int easingFunc, float t) { return t; }vec3 hash33(vec3 p3) { p3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787)); p3 += dot(p3, p3.yxz + 19.19); return -1.0 + 2.0 * fract(vec3( (p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x )); }float perlin_noise(vec3 p) { vec3 pi = floor(p); vec3 pf = p - pi;vec3 w = pf * pf * (3.0 - 2.0 * pf);float n000 = dot(pf - vec3(0.0, 0.0, 0.0), hash33(pi + vec3(0.0, 0.0, 0.0))); float n100 = dot(pf - vec3(1.0, 0.0, 0.0), hash33(pi + vec3(1.0, 0.0, 0.0))); float n010 = dot(pf - vec3(0.0, 1.0, 0.0), hash33(pi + vec3(0.0, 1.0, 0.0))); float n110 = dot(pf - vec3(1.0, 1.0, 0.0), hash33(pi + vec3(1.0, 1.0, 0.0))); float n001 = dot(pf - vec3(0.0, 0.0, 1.0), hash33(pi + vec3(0.0, 0.0, 1.0))); float n101 = dot(pf - vec3(1.0, 0.0, 1.0), hash33(pi + vec3(1.0, 0.0, 1.0))); float n011 = dot(pf - vec3(0.0, 1.0, 1.0), hash33(pi + vec3(0.0, 1.0, 1.0))); float n111 = dot(pf - vec3(1.0, 1.0, 1.0), hash33(pi + vec3(1.0, 1.0, 1.0)));float nx00 = mix(n000, n100, w.x); float nx01 = mix(n001, n101, w.x); float nx10 = mix(n010, n110, w.x); float nx11 = mix(n011, n111, w.x);float nxy0 = mix(nx00, nx10, w.y); float nxy1 = mix(nx01, nx11, w.y);float nxyz = mix(nxy0, nxy1, w.z);return nxyz; }const int OCTAVES = 6; const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }mat2 rotHalf = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));float fbm (in vec3 st) { float value = 0.0; float amp = .25; float frequency = 0.; float aM = (0.1 + 0.37 * .65); vec2 shift = vec2(100.0); for (int i = 0; i < OCTAVES; i++) { value += amp * perlin_noise(st); st.xy *= rotHalf * 2.5; st.xy += shift; amp *= aM; } return value; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y; float multiplier = 6.0 * (0.03 / ((aspectRatio + 1.) / 2.));vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.36); vec2 pos = vec2(0.5, 0.5); float mDist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 0.37)));vec2 st = (uv * vec2(aspectRatio, 1) + (1. - pos) - vec2(1)) * multiplier * aspectRatio; st = rot(0.00 * -1. * 2.0 * PI) * st; vec2 drift = vec2(uTime * 0.005);float time = uTime * 0.025;vec2 r = vec2( fbm(vec3(st - drift + vec2(1.7, 9.2), 0.00*25. + time)), fbm(vec3(st - drift + vec2(8.2, 1.3), 0.00*25. + time)) );float f = fbm(vec3(st + r - drift, 0.00*25. + time)) * 0.13;vec2 offset = (f * 2. + (r * 0.13));vec4 color = texture(uTexture, uv + offset * mDist); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{}}}],"options":{"name":"Operator","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"1.4.1","id":"KlhhipkWy8SaYhUJHgRv"}